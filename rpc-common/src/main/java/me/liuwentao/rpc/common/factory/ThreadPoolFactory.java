package me.liuwentao.rpc.common.factory;import com.google.common.util.concurrent.ThreadFactoryBuilder;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.Map;import java.util.concurrent.*;/** * Created by liuwentao on 2021/6/28 16:15 * * v3.1版本中优化线程池创建工厂；新增一个concurrentHashMap<String, ExecutorService>来存储、管理所有创建的线程池； * 包括：创建默认线程池、关闭所有线程池。。。 */public class ThreadPoolFactory {    private static final Logger logger = LoggerFactory.getLogger(ThreadPoolFactory.class);    private static final int CORE_POOL_SIZE = 10;    private static final int MAX_POOL_SIZE = 10;    private static final int KEEP_ALIVE_TIME = 1;    private static final int BLOCKING_QUEUE_CAPACITY = 10;    // 把ThreadPoolFactory设为private；让其它类无法构造线程池工厂类    private ThreadPoolFactory() {    }    private static final Map<String, ExecutorService> threadPollsMap = new ConcurrentHashMap<>();    // 线程池中每个线程的线程名前缀    public static ExecutorService createDefaultThreadPool(String threadNamePrefix) {        return createDefaultThreadPool(threadNamePrefix, false);    }    public static ExecutorService createDefaultThreadPool(String threadNamePrefix, Boolean daemon) {        ExecutorService pool = threadPollsMap.computeIfAbsent(threadNamePrefix, k -> createThreadPool(threadNamePrefix, daemon));        if (pool.isShutdown() || pool.isTerminated()) {            threadPollsMap.remove(threadNamePrefix);            pool = createDefaultThreadPool(threadNamePrefix, daemon);            threadPollsMap.put(threadNamePrefix, pool);        }        return pool;    }    public static ExecutorService createThreadPool(String threadNamePrefix, Boolean daemon) {        // 阻塞队列        BlockingQueue<Runnable> blockingQueue = new ArrayBlockingQueue(BLOCKING_QUEUE_CAPACITY);        ThreadFactory threadFactory = createThreadFactory(threadNamePrefix, daemon);        return new ThreadPoolExecutor(CORE_POOL_SIZE, MAX_POOL_SIZE, KEEP_ALIVE_TIME, TimeUnit.SECONDS, blockingQueue                , threadFactory);    }    // 关闭所有线程池    public static void shutdownAll() {        logger.info("关闭所有线程池...");        for (Map.Entry<String, ExecutorService> threadPool : threadPollsMap.entrySet()) {            ExecutorService executorService = threadPool.getValue();            executorService.shutdown();            logger.info("关闭线程池{}{}", threadPool.getKey(), executorService.isTerminated());            try {                executorService.awaitTermination(10, TimeUnit.SECONDS);            } catch (InterruptedException e) {                logger.error("关闭线程池失败", e);                executorService.shutdownNow();            }        }    }    private static ThreadFactory createThreadFactory(String threadNamePrefix, Boolean daemon) {        if (threadNamePrefix != null) {            // 创建一个线程也分为两种，是否是守护线程            if (daemon != null) {                return new ThreadFactoryBuilder().setDaemon(daemon).setNameFormat(threadNamePrefix + "-%d").build();            } else {                return new ThreadFactoryBuilder().setNameFormat(threadNamePrefix + "-%d").build();            }        }        return Executors.defaultThreadFactory();    }}