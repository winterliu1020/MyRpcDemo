package me.liuwentao.rpc.common.util;import com.google.common.util.concurrent.ThreadFactoryBuilder;import java.util.concurrent.*;/** * Created by liuwentao on 2021/6/28 16:15 */public class ThreadPoolFactory {    private static final int CORE_POOL_SIZE = 10;    private static final int MAX_POOL_SIZE = 10;    private static final int KEEP_ALIVE_TIME = 1;    private static final int BLOCKING_QUEUE_CAPACITY = 10;    // 把ThreadPoolFactory设为private；让其它类无法构造线程池工厂类    private ThreadPoolFactory() {    }    // 线程池中每个线程的线程名前缀    public static ExecutorService createDefaultThreadPool(String threadNamePrefix) {        return createDefaultThreadPool(threadNamePrefix, false);    }    public static ExecutorService createDefaultThreadPool(String threadNamePrefix, Boolean daemon) {        // 阻塞队列        BlockingQueue<Runnable> blockingQueue = new ArrayBlockingQueue(BLOCKING_QUEUE_CAPACITY);        ThreadFactory threadFactory = createThreadFactory(threadNamePrefix, daemon);        return new ThreadPoolExecutor(CORE_POOL_SIZE, MAX_POOL_SIZE, KEEP_ALIVE_TIME, TimeUnit.SECONDS, blockingQueue                , threadFactory);    }    private static ThreadFactory createThreadFactory(String threadNamePrefix, Boolean daemon) {        if (threadNamePrefix != null) {            // 创建一个线程也分为两种，是否是守护线程            if (daemon != null) {                return new ThreadFactoryBuilder().setDaemon(daemon).setNameFormat(threadNamePrefix + "-%d").build();            } else {                return new ThreadFactoryBuilder().setNameFormat(threadNamePrefix + "-%d").build();            }        }        return Executors.defaultThreadFactory();    }}