package me.liuwentao.rpc.core.transport.Netty.client;import io.netty.bootstrap.Bootstrap;import io.netty.channel.*;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import me.liuwentao.rpc.common.Enumeration.RpcError;import me.liuwentao.rpc.common.Exception.RpcException;import me.liuwentao.rpc.core.Serializer.CommonSerializer;import me.liuwentao.rpc.core.codec.CommonDecoder;import me.liuwentao.rpc.core.codec.CommonEncoder;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.net.InetSocketAddress;import java.util.Date;import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;/** * Created by liuwentao on 2021/6/30 10:35 * * 根据inetSocketAddress和serializer获取一个channel；bootstrap设置的一些参数放在initBootstrap()方法中；而每次执行一个get()方法我都需要为bootstrap设置handler； * 注意：bootstrap对象可以设置成static类型； */public class ChannelProvider {    private static final Logger logger = LoggerFactory.getLogger(ChannelProvider.class);    private static final Bootstrap bootstrap = initBootstrap(); // 相当于这个bootstrap还是static类型，属于ChannelProvider这个类    private static final int MAX_TRY = 5; // client连接server最大重试次数    // 这里可能是一个bug；    private static Channel channel;    public static synchronized Channel get(InetSocketAddress inetSocketAddress, CommonSerializer serializer) {        // 随着加载ChannelProvider完成了bootstrap的初步初始化，但是还没有设置handler        bootstrap.handler(new ChannelInitializer<SocketChannel>() {            @Override            protected void initChannel(SocketChannel channel) throws Exception {                ChannelPipeline channelPipeline = channel.pipeline();                // 在client端需要加哪些handler：                channelPipeline.addLast(new CommonEncoder(serializer));                channelPipeline.addLast(new CommonDecoder());                channelPipeline.addLast(new NettyClientHandler()); // nettyClientHandler这个handler直接和client端打交道            }        });        // 从ChannelProvider这个类的角度来看，这里面应该有一个channel属性        // countDownLatch用于通知        CountDownLatch countDownLatch = new CountDownLatch(1);        // handler设置完之后就可以执行connect操作了，这里不用返回channel 而是把channel定义在方法外；这里还对连接增加了一个重连机制        connect(bootstrap, inetSocketAddress, countDownLatch);        try {            countDownLatch.await();        } catch (InterruptedException e) {            logger.error("获取channel时发生错误...");        }        return channel;    }    /*    * 这里插一点Java异常的知识：参考 https://blog.csdn.net/hellojoy/article/details/103270370    * 1. 异常大致分为RuntimeException和非RuntimeException，非RuntimeException必须用try    * catch进行捕获，或者通过throws交由上层处理，否则编译都无法通过；当然如果你仅仅是throws给上层处理，当发生异常的时候，try catch块后面的所有代码还是无法执行    * 2. RuntimeException虽然可以编译通过，但是如果你不进行catch的话，它会交由JVM来处理，JVM在你写的代码中找不到处理这个异常的try catch，所以会终止程序    * 3. JAVA执行过程出现异常,系统会监测到并自动生成一个相应的异常类对象,然后再将它交给运行时系统，或者你通过throw new xxException()也是一样的交由JVM处理    * */    private static void connect(Bootstrap bootstrap, InetSocketAddress inetSocketAddress,                                CountDownLatch countDownLatch) {        connect(bootstrap, inetSocketAddress, 1, countDownLatch); // retry是指连接的次数    }    private static void connect(Bootstrap bootstrap, InetSocketAddress inetSocketAddress, int tryTimes,                                CountDownLatch countDownLatch) {        // 尝试连接        ChannelFuture channelFuture = bootstrap.connect(inetSocketAddress);        channel = channelFuture.channel();        // 看看是否连接成功        channelFuture.addListener(new ChannelFutureListener() {            @Override            public void operationComplete(ChannelFuture channelFuture) throws Exception {                if (channelFuture.isSuccess()) {                    // 如果成功了就把倒计时的门打开，让所有线程通过                    countDownLatch.countDown(); // 匿名内部类函数中可以用外部函数中的形参；但是不能用函数体中定义的局部变量 比如channel                    return;                }                // 如果此次连接不成功，查看tryTimes次数是否超过MAX_TRY                if (tryTimes > MAX_TRY) {                    // 连接失败                    throw new RpcException(RpcError.CLIENT_CONNECT_SERVER_FAILURE);                }                // 本次重连的间隔                int delay = 1 << tryTimes; // tryTimes表示第几次连接；delay的时间越来越久                logger.error("{}连接失败，第{}次重连...", new Date(), tryTimes);                // 执行一个间隔指定时间然后再连接的函数                bootstrap.config().group().schedule(()->{                    connect(bootstrap, inetSocketAddress, tryTimes, countDownLatch);                }, delay, TimeUnit.SECONDS);            }        });    }    // 初始化Bootstrap    public static Bootstrap initBootstrap() {        EventLoopGroup eventLoopGroup = new NioEventLoopGroup();        Bootstrap bootstrap = new Bootstrap();        bootstrap.group(eventLoopGroup)                .channel(NioSocketChannel.class)                .option(ChannelOption.SO_KEEPALIVE, true)                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)                .option(ChannelOption.TCP_NODELAY, true);        return bootstrap;    }}